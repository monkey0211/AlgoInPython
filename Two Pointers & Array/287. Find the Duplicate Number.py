'''
答案参考: https://leetcode.jp/leetcode-287-find-the-duplicate-number-%E8%A7%A3%E9%A2%98%E6%80%9D%E8%B7%AF%E5%88%86%E6%9E%90/
双指针 快慢指针 首先我们可以将数组想象成为一个环状的LinkedList 因为数组中的数字的取值范围在1-n之间
我们可以将任何一位的数字理解为它下一个节点的位置 比如nums[3]=6 也就是下标为3的节点的下一个节点是下标为6的节点 
另外注意一点 由于取值范围内不包含0 因此没有节点会指向下标为0的点。我们来看个完整的例子 比如下面这个数组：
val: 6 2 4 6 8 3 1 5 7
idx: 0 1 2 3 4 5 6 7 8
画一张图 节点编号为idx 可以看出 6的位置出现了环:0和3均指向6
我们定义2个指针 快指针和慢指针 两个指针起初同时从下标0出发 慢指针一次走一步 快指针一次走两步 
如果路径上不存在环的话 快指针会先走完整条路径 慢指针会使用快指针2倍的时间走完路径。
不过本题在上面已经证明过一定存在环 因此 两个指针一定会在环上的某一点相遇
（题外话 反过来 如果两指针能相遇 可以证明链表上存在回路 也就是环）
相遇后 我们将其中一个指针的位置不变 另外一个指针回到位置0 然后再以每次前进一步的相同的速度继续走 
直到两指针再次相遇时 该相遇点一定是边与环的交点
简单证明一下 我们设起点S到与环相交点X的距离(步数 每一步走一个距离单位)为a 相交点X到两指针相遇点Y的距离为b 圆环的周长是c 
因此 相遇时 慢指针走的步数为a+b 而快指针比慢指针多绕了一圈 因此快指针走的步数为a+b+c 并且我们还知道 快指针每次走两步 
而慢指针每次走一步 因此相遇时 快指针走的总步数是慢指针的2倍 即:
a+b+c=2(a+b);
即：
c=a+b;
结论即是 圆环的周长等于 起点S到与圆环相交点X的距离 加上圆环交点X到圆环上两指针相遇点Y距离之和。
也就是说 此时从两指针相遇点Y到圆环相交点X的距离等于起点S到X的距离 这样将某一个指针放回起点 再以相同速度前进的话 
必然会在X点相遇 该点即是我们要求的答案。
time O(n)  space O(1)
'''
class Solution:
    def findDuplicate(self, nums: List[int]) -> int:
        # 慢指针走一步
        slow = nums[0]
        # 快指针走两步
        fast = nums[nums[0]]
        # 两指针同时走 直到相遇
        while slow != fast:
            slow = nums[slow]
            fast = nums[nums[fast]]
        # 将快指针放回起点
        fast = 0
        # 两指针以同样速度前进 再次相遇时即为答案
        while slow != fast:
            slow = nums[slow]
            fast = nums[fast]
        return fast